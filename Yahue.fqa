{"initialProperties":{"quickAppUuid":"UPD896846032517896","uiCallbacks":[{"callback":"restart","eventType":"onReleased","name":"restart"},{"callback":"","eventType":"onLongPressDown","name":"restart"},{"callback":"","eventType":"onLongPressReleased","name":"restart"},{"callback":"dumpResources","eventType":"onReleased","name":"dump"},{"callback":"","eventType":"onLongPressDown","name":"dump"},{"callback":"","eventType":"onLongPressReleased","name":"dump"}],"viewLayout":{"$jason":{"body":{"sections":{"items":[{"components":[{"text":"","visible":true,"type":"label","style":{"weight":"1.2"},"name":"info"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"text":"Restart","visible":true,"type":"button","style":{"weight":"1.2"},"name":"restart"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"text":"Dump resources","visible":true,"type":"button","style":{"weight":"1.2"},"name":"dump"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]},"header":{"style":{"height":"150"},"title":"quickApp_device_52"}},"head":{"title":"quickApp_device_52"}}},"uiView":[{"type":"horizontal","style":{"weight":"1.0"},"components":[{"text":"","visible":true,"type":"label","style":{"weight":"1.0"},"name":"info"}]},{"type":"horizontal","style":{"weight":"1.0"},"components":[{"eventBinding":{"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","restart"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","restart"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","restart"]},"type":"deviceAction"}]},"visible":true,"type":"button","text":"Restart","style":{"weight":"1.0"},"name":"restart"}]},{"type":"horizontal","style":{"weight":"1.0"},"components":[{"eventBinding":{"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","dump"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","dump"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","dump"]},"type":"deviceAction"}]},"visible":true,"type":"button","text":"Dump resources","style":{"weight":"1.0"},"name":"dump"}]}],"quickAppVariables":[{"value":"192.168.1.153","name":"Hue_IP"},{"value":"AqlHjZVly4IRgcDmzr5YfJhDWs-lig0zitdckmn9","name":"Hue_User"}],"apiVersion":"1.3","useUiView":false,"typeTemplateInitialized":true},"initialInterfaces":["quickApp"],"type":"com.fibaro.deviceController","apiVersion":"1.3","files":[{"isMain":false,"type":"lua","content":"--[[\nGNU GENERAL PUBLIC LICENSE\nVersion 3, 29 June 2007\n\nCopyright (C) 2007 Free Software Foundation, Inc. <https:\/\/fsf.org\/>\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\n(C) 2022 jan@gabrielsson.com\n--]]\n\n-- luacheck: globals ignore quickApp plugin api net netSync setTimeout clearTimeout setInterval clearInterval json\n-- luacheck: globals ignore hc3_emulator HUEv2Engine fibaro\n-- luacheck: globals ignore homekit device light zigbee_connectivity device_power zgp_cpnnectivity entertainment entertainment_configuration\n-- luacheck: globals ignore room zone grouped_light scene button relative_rotary temperature motion light_level bridge bridge_home behavior_script\n-- luacheck: globals ignore behavior_instance geolocation geolocation_client\n-- luacheck: ignore 212\/self\n\nlocal version = 0.47\n\nlocal fmt = string.format\nfibaro.debugFlags = fibaro.debugFlags or {}\nlocal debug = fibaro.debugFlags\nlocal function DEBUG(flag,fm,...) if debug[flag] then quickApp:debug(fmt(fm,...)) end end\nlocal function WARNING(fm,...) quickApp:warning(fmt(fm,...)) end\nlocal function ERROR(fm,...) quickApp:error(fmt(fm,...)) end\n\nHUEv2Engine = HUEv2Engine or {}\nHUEv2Engine.version = version\nfibaro.hue = fibaro.hue or {}\nfibaro.hue.Engine = HUEv2Engine\nlocal function setup()\nend\nlocal function strip(l) local r={} for k,v in pairs(l) do r[#r+1]=k end return r end\n\n--[[\ndebug.info          -- greetings etc\ndebug.class         -- class creation\ndebug.resource_mgmt -- creation\/delation\/modification of object\ndebug.event         -- incoming event from Hue hub\ndebug.v2api         -- v2api info (unhandled events etc)\ndebug.call          -- http calls to Hue hub\ndebug.unknownType   -- Unhandled device updates\ndebug.logger        -- Logs subscribption events\n--]]\n\n--[[\nRoom--+\n|             +------ Service A\n|             |\n+---Device ---+\n|\n+--+------ Service B\n|\nZone-------------+\n|\n+----- Service - Grouped Light\n--]]\n\nif not fibaro.event then\n  local _events={}\n  function fibaro.event(ev,h) _events[ev.type]=h end\n  function fibaro.post(ev,t)\n    return setTimeout(function() _events[ev.type](ev) end,t or 0)\n  end\nend\n\nlocal function copyShallow(t) local r = {} for k,v in pairs(t) do r[k]=v end return r end\nlocal function copy(t) \n  local r = {} \n  for k,v in pairs(t) do if type(v)=='table' then r[k]=copy(v) else r[k]=v end end \n  return r\nend\n\nlocal function keyMerge(t1,t2)\n  local res = copy(t1)\n  for k,v in pairs(t2) do if t1[k]==nil then t1[k]=v end end\n  return res\nend\n\nlocal _initEngine\nlocal function main()\n  local v2 = \"1948086000\"\n  local OPTIMISTIC = false\n  local err_retry = 3\n  local post = fibaro.post\n  local resources = {}\n  local props,meths={},{}\n  local hueGET,huePUT\n  local app_key,url,callBack\n  local fmt = string.format\n  local merge = keyMerge\n  local classes = {}\n  local function createResourceTable()\n    local self = { resources={}, id2resource={} }\n    local resources,id2resource = self.resources,self.id2resource\n    function self.changeHook() end\n    function self.add(id,rsrc)\n      local typ = rsrc.type\n      if id2resource[id] then self.modify(id,rsrc)\n      else\n        if classes[typ] then\n          rsrc = classes[typ](rsrc)\n        else\n          WARNING(\"Missing resource type:%s\",typ)\n          return\n        end\n        resources[typ]=resources[typ] or {};\n        resources[typ][id]=rsrc;\n        id2resource[id]=rsrc\n        rsrc:added()\n      end\n    end\n    function self.modify(id,rsrc)\n      assert(id2resource[id],\"No resource for modify\")\n      id2resource[id]:modify(rsrc)\n    end\n    function self.delete(id)\n      local rsrc=id2resource[id]\n      assert(rsrc,\"No resource\")\n      resources[rsrc.type][id]=nil\n      rsrc:deleted()\n      id2resource[id]=nil\n    end\n    function self.get(id) return id2resource[id] end\n    return self\n  end\n  \n  local function resolve(rr)\n    return rr and resources.get(rr.rid) or \n    { subscribe=function(_,_,_) end, publishMySubs=function() end, publishAll=function() end } \n  end\n  \n  local function classs(name,parent)\n    local p = class(name)\n    local cl = _G[name]\n    classes[name] = cl\n    _G[name] = nil\n    if parent then p(parent) end\n    return cl\n  end\n  \n  local hueResource = classs('hueResource')\n  function hueResource:__init(rsrc) self:setup(rsrc) end\n  \n  function hueResource:setup(rsrc)\n    local id = rsrc.id\n    self.id = id\n    for m,_ in pairs(self._inheritedFuns or {}) do self[m]=nil end\n    self.rsrc = rsrc\n    self.type = rsrc.type\n    self.services = rsrc.services\n    self.children = rsrc.children\n    self.owner = rsrc.owner\n    self.metadata = rsrc.metadata or {}\n    self.product_data = rsrc.product_data or {}\n    self.resourceType = self.product_data.model_id or self.metadata.archetype or \"unknown\"\n    self.resourceName = self.product_data.product_name\n    self.name = self.metadata.name\n    self._inheritedFuns = {}\n    self.path = \"\/clip\/v2\/resource\/\"..self.type..\"\/\"..self.id\n    self._inited = true\n    self.listernes = {}\n    self._props = props[self.type]\n    self._meths = meths[self.type]\n    DEBUG(\"class\",\"Setup %s '%s' %s\",self.id,self.type,self.name or \"rsrc\")\n  end\n  function hueResource:getName(dflt)\n    if self.name then return self.name end\n    local n = resolve(self.owner).name\n    if n then self.name = n return n end\n    return dflt\n  end\n  function hueResource:added() DEBUG('resource_mgmt',\"Created %s\",tostring(self)) end\n  function hueResource:deleted() DEBUG('resource_mgmt',\"Deleted %s\",tostring(self)) end\n  function hueResource:modified(rsrc) self:setup(rsrc) DEBUG('resource_mgmt',\"Modified %s\",tostring(self)) end\n  function hueResource:findServiceByType(typ)\n    local r = {}\n    for _,s in ipairs(self.services or {}) do local x=resolve(s) if x.type==typ then r[#r+1]=x end end\n    return r\n  end\n  function hueResource:getCommand(cmd)\n    if self[cmd] then return self end\n    for _,s in ipairs(self.services or {}) do\n      local x=resolve(s)\n      if x[cmd] then return x end\n    end\n  end\n  \n  function hueResource:getProps()\n    local r,btns = {},0\n    for _,s in ipairs(self.services or {}) do\n      local r1 = resolve(s) or {}\n      local ps = r1.getProps and r1:getProps() or {}\n      merge(r,ps)\n    end\n    merge(r,self._props or {})\n    return r\n  end\n  function hueResource:getMethods()\n    local r = {}\n    for _,s in ipairs(self.services or {}) do merge(r,resolve(s):getMethods()) end\n    merge(r,self._meths or {})\n    return r\n  end\n  function hueResource:event(data)\n    DEBUG('event',\"Event: %s\",data)\n    if self.update then self:update(data) return end\n    local p = self._props -- { power_state = { get, set changed }, ...\n    if p then\n      local r = self.rsrc\n      for k,f in pairs(p) do\n        if data[k] and f.changed then\n          local c,v = f.changed(r,data)\n          if c then\n            f.set(r,v)\n            self:publish(k,v)\n          end\n        end\n      end\n    end\n    if self.owner then\n      local o = resolve(self.owner)\n      if o._postEvent then o:_postEvent(self.id) end\n    end\n  end\n  function hueResource:publishMySubs()\n    local p = self._props -- { power_state = { get, set changed }, ...\n    if p then\n      local r = self.rsrc\n      for k,f in pairs(p) do\n        if r[k] then self:publish(k,f.get(r)) end\n      end\n    end\n  end\n  function hueResource:publishAll()\n    if self.services then\n      for _,s in ipairs(self.services or {}) do resolve(s):publishMySubs() end\n    else\n      self:publishMySubs()\n    end\n    if self._postEvent then self:_postEvent(self.id) end\n  end\n  function hueResource:publish(key,value)\n    local ll = self.listernes[key] or {}\n    if next(ll) then\n      for l,_ in pairs(ll) do\n        l(key,value,self)\n      end\n    end\n  end\n  \n  function hueResource:subscribe(key,fun)\n    if self.services then\n      for _,s in ipairs(self.services or {}) do resolve(s):subscribe(key,fun) end\n    elseif self._props and self._props[key] then\n      self.listernes[key] = self.listernes[key] or {}\n      self.listernes[key][fun]=true\n    end\n  end\n  function hueResource:unsubscribe(key,fun)\n    for _,s in ipairs(self.services or {}) do resolve(s):unsubscribe(key,fun) end\n    if self.listernes[key] then\n      if fun==true then self.listernes[key]={}\n      else self.listernes[key][fun]=nil end\n    end\n  end\n  function hueResource:sendCmd(cmd) return huePUT(self.path,cmd) end\n  function hueResource:__tostring() return self._str or fmt(\"[rsrc:%s]\",self.id) end\n  function hueResource:annotateEvent(r)\n    return setmetatable(r,{\n      __tostring = function(r)\n        return fmt(\"%s %s\",r.type,self.name or r.id_v1 or \"\") \n      end\n    })\n  end\n  -------\n  \n  local homekit = classs('homekit',hueResource)\n  function homekit:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[homekit:%s]\",self.id)\n  end\n  \n  local device = classs('device',hueResource)\n  function device:__init(id)\n    hueResource.__init(self,id)\n    self.archetype = self.rsrc.metadata.archetype\n    self.name = self.name or \"device\"\n    self._str = fmt(\"[device:%s,%s,%s]\",self.id,self.name,self.resourceType)\n  end\n  \n  local pprops = { color={\"setColor\"},color_temperature={\"setTemperature\"},dimming={\"setDim\"} }\n  local function pruneLights(self)\n    self._props = copyShallow(self._props)\n    self._meths = copyShallow(self._meths)\n    for p,m in pairs(pprops) do\n      if self.rsrc[p]==nil then\n        self._props[p]=nil\n        for _,f in ipairs(m) do self._meths[f]=nil end\n      end\n    end\n  end\n  \n  local light = classs('light',hueResource)\n  function light:__init(id)\n    hueResource.__init(self,id)\n    self.archetype = resolve(self.owner).archetype or \"unknown_archetype\"\n    pruneLights(self)\n    self._str = fmt(\"[light:%s,%s,%s]\",self.id,self:getName(\"LGHT\"),self.resourceType)\n  end\n  function light:turnOn(transition) self:sendCmd({on={on=true},dynamics=transition and {duration=transition} or nil}) if OPTIMISTIC then self.rsrc.on.on = true end end\n  function light:turnOff(transition) self:sendCmd({on={on=false},dynamics=transition and {duration=transition} or nil}) if OPTIMISTIC then self.rsrc.on.on = true end end\n  function light:setDim(val,transition)\n    if val == -1 then\n      self:sendCmd({dimming_delta={action='stop'}})\n    else\n      self:sendCmd({dimming={brightness=val},dynamics=transition and {duration=transition} or nil})\n    end\n  end\n  function light:setColor(arg,transition) -- {x=x,y=y} <string>, {r=r,g=g,b=b}\n    local xy\n    if type(arg)=='string' then\n      xy = HUEv2Engine.xyColors[tostring(arg:lower())] or HUEv2Engine.xyColors['white']\n    elseif type(arg)=='table' then\n      if arg.x and arg.y then xy = arg\n      elseif arg.r and arg.g and arg.b then\n      end\n    end\n    if xy then self:sendCmd({color={xy=xy},dynamics=transition and {duration=transition} or nil}) end\n  end\n  function light:toggle(transition)\n    local on = self.rsrc.on.on\n    self:sendCmd({on={on=not on},dynamics=transition and {duration=transition} or nil})\n    if OPTIMISTIC then self.rsrc.on.on = not on end\n  end\n  function light:rawCmd(cmd) self:sendCmd(cmd) end\n  function light:setTemperature(t,transition) self:sendCmd({color_temperature={mirek=math.floor(t+0.5)},dynamics=transition and {duration=transition} or nil}) end\n  meths.light = { turnOn=true, turnOff=true, setDim=true, setColor=true, setTemperature=true, toggle=true, rawCmd=true }\n  props.light = {\n    on={get=function(r) return r.on.on end,set=function(r,v) r.on.on=v end, changed=function(o,n) return o.on.on ~= n.on.on, n.on.on end },\n    dimming={\n      get=function(r) return r.dimming.brightness end,\n      set=function(r,v) r.dimming.brightness=v end,\n      changed=function(o,n) return o.dimming.brightness~=n.dimming.brightness,n.dimming.brightness end,\n    },\n    color_temperature={\n      get=function(r) return r.color_temperature.mirek end,\n      set=function(r,v) r.color_temperature.mirek=v end,\n      changed=function(o,n) return n.color_temperature.mirek_valid and o.color_temperature.mirek~=n.color_temperature.mirek,n.color_temperature.mirek end,\n    },\n    color={\n      get=function(r) return r.color.xy end,\n      set=function(r,v) r.color.xy=v end,\n      changed=function(o,n)\n        local oxy,nxy = o.color.xy,n.color.xy\n        return oxy.x~=nxy.x or oxy.y~=nxy.y,nxy\n      end,\n    },\n  }\n  \n  props.zigbee_connectivity = {\n    status={\n      get=function(r) return r.status end,\n      set=function(r,v) r.status=v end,\n      changed=function(o,n) return o.status~=n.status,n.status end,\n    },\n  }\n  local zigbee_connectivity = classs('zigbee_connectivity',hueResource)\n  function zigbee_connectivity:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[zigbee_connectivity:%s,%s]\",self.id,self:getName(\"CON\"))\n  end\n  function zigbee_connectivity:connected()\n    return self.rsrc.status==\"connected\"\n  end\n  \n  props.device_power = {\n    power_state={\n      get=function(r) return r.power_state end,\n      set=function(r,v) r.power_state=v end,\n      changed=function(o,n) local s0,s1 = o.power_state,n.power_state return s0.battery_state~=s1.battery_state or s0.battery_level~=s1.battery_level,s1  end\n    },\n  }\n  local device_power = classs('device_power',hueResource)\n  function device_power:__init(id)\n    hueResource.__init(self,id)\n  end\n  function device_power:power()\n    return self.rsrc.power_state.battery_level,self.rsrc.power_state.battery_state\n  end\n  function device_power:__tostring()\n    return fmt(\"[device_power:%s,%s,value:%s]\",self.id,self:getName(),self:power())\n  end\n  function device_power:event(data)\n    hueResource.event(self,data)\n  end\n  \n  props.zgp_connectivity = {\n    status={get=function(r) return r.status end,set=function(r,v) r.status=v end},\n  }\n  meths.zgp_connectivity = { connected=true }\n  local zgp_connectivity = classs('zgp_connectivity',hueResource)\n  function zgp_connectivity:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[zgp_connectivity:%s,%s]\",self.id,self:getName(\"ZGP\"))\n  end\n  function zgp_connectivity:connected()\n    return self.rsrc.status==\"connected\"\n  end\n  \n  local zigbee_device_discovery = classs('zigbee_device_discovery',hueResource)\n  function zigbee_device_discovery:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[zigbee_device_discovery:%s,%s]\",self.id,self:getName(\"ZDD\"))\n  end\n  \n  local device_software_update = classs('device_software_update',hueResource)\n  function device_software_update:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[device_software_update:%s,%s]\",self.id,self:getName(\"DSU\"))\n  end\n  \n  props.contact = {\n    contact_report={\n      get=function(r) return (r.contact_report or {}).state or \"off\" end,\n      set=function(r,v) r.contact_report.state=v end,\n      changed=function(o,n) return o.contact_report.state~=n.contact_report.state,n.contact_report.state end,\n    },\n  }\n  local contact = classs('contact',hueResource)\n  function contact:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[contact:%s,%s]\",self.id,self:getName(\"CON\"))\n  end\n  \n  props.tamper = {\n    tamper={\n      get=function(r) return r.tamper_reports[1].state end,\n      set=function(r,v) r.tamper_reports[1].state=v end,\n      changed=function(o,n) return o.tamper[1].state~=n.tamper[1].state,n.tamper[1].state end,\n    },\n  }\n  local tamper = classs('tamper',hueResource)\n  function tamper:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[tamper:%s,%s]\",self.id,self:getName(\"TAM\"))\n  end\n  \n  local matter = classs('matter',hueResource)\n  function matter:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[matter:%s,%s]\",self.id,self:getName(\"MATT\"))\n  end\n  \n  local entertainment = classs('entertainment',hueResource)\n  function entertainment:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[entertainment:%s,%s]\",self.id,self:getName(\"ENT\"))\n  end\n  \n  local entertainment_configuration = classs('entertainment_configuration',hueResource)\n  function entertainment_configuration:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[entertainment_configuration:%s,%s]\",self.id,self:getName(\"ENT_CFG\"))\n  end\n  \n  meths.room = { targetCmd=true }\n  local room = classs('room',hueResource)\n  function room:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[room:%s,%s,%s]\",self.id,self.name,self.resourceType)\n  end\n  function room:setup(rsrc) hueResource.setup(self,rsrc) self.resourceName=\"Room\" end\n  function room:targetCmd(cmd)\n    for _,s in ipairs(self.services or {}) do\n      s = resolve(s)\n      if s and s.type == 'grouped_light' then\n        s:sendCmd(cmd)\n      end\n    end\n  end\n  \n  meths.zone = { targetCmd=true }\n  local zone = classs('zone',hueResource)\n  function zone:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[zone:%s,%s,%s]\",self.id,self.name,self.resourceType)\n  end\n  function zone:setup(rsrc) hueResource.setup(self,rsrc) self.resourceName=\"Zone\" end\n  function zone:targetCmd(cmd)\n    for _,s in ipairs(self.services or {}) do\n      s = resolve(s)\n      if s and s.type == 'grouped_light' then\n        s:sendCmd(cmd)\n      end\n    end\n  end\n  \n  props.grouped_light = props.light\n  meths.grouped_light = meths.light\n  local grouped_light = classs('grouped_light',hueResource)\n  function grouped_light:__init(id)\n    hueResource.__init(self,id)\n    pruneLights(self)\n  end\n  function grouped_light:__tostring() return fmt(\"[grouped_light:%s,%s]\",self.id,self:getName(\"GROUP\")) end\n  function grouped_light:turnOn(transition) self:sendCmd({on={on=true},dynamics=transition and {duration=transition} or nil}) if OPTIMISTIC then self.rsrc.on.on = true end end\n  function grouped_light:turnOff(transition) self:sendCmd({on={on=false},dynamics=transition and {duration=transition} or nil}) if OPTIMISTIC then self.rsrc.on.on = true end end\n  function grouped_light:setDim(val,transition)\n    if val == -1 then\n      self:sendCmd({dimming_delta={action='stop'}})\n    else\n      self:sendCmd({dimming={brightness=val},dynamics=transition and {duration=transition} or nil})\n    end\n  end\n  function grouped_light:setColor(arg,transition) -- {x=x,y=y} <string>, {r=r,g=g,b=b}\n    local xy\n    if type(arg)=='string' then\n      xy = HUEv2Engine.xyColors[tostring(arg:lower())] or HUEv2Engine.xyColors['white']\n    elseif type(arg)=='table' then\n      if arg.x and arg.y then xy = arg\n      elseif arg.r and arg.g and arg.b then\n      end\n    end\n    if xy then self:sendCmd({color={xy=xy},dynamics=transition and {duration=transition} or nil}) end\n  end\n  function light:toggle(transition)\n    local on = self.rsrc.on.on\n    self:sendCmd({on={on=not on},dynamics=transition and {duration=transition} or nil})\n    if OPTIMISTIC then self.rsrc.on.on = not on end\n  end\n  function light:rawCmd(cmd) self:sendCmd(cmd) end\n  function grouped_light:setTemperature(t,transition) self:sendCmd({color_temperature={mirek=math.floor(t+0.5)},dynamics=transition and {duration=transition} or nil}) end\n  \n  meths.scene = { recall=true, targetCmd=true }\n  local scene = classs('scene',hueResource)\n  function scene:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[scene:%s,%s]\",self.id,self.name)\n  end\n  function scene:recall(transition) self:sendCmd({recall = { action = \"active\",dynamics=transition and {duration=transition} or nil  }}) end\n  function scene:targetCmd(cmd)\n    if not self.rsrc.group then return end\n    local zoneroom = resolve(self.rsrc.group)\n    if not zoneroom then return end\n    if zoneroom.targetCmd then zoneroom:targetCmd(cmd) end\n  end\n  \n  props.button = {\n    button = {\n      get=function(r) if r.button then return r.button end end,\n      set=function(r,v) if not r.button then r.button = { last_event = v } else r.button.last_event=v end end,\n      changed=function(o,n)\n        local ob,nb = o.button or {},n.button or {}\n        return ob.last_event~=nb.last_event,nb.last_event\n      end\n    }\n  }\n  local button = classs('button',hueResource)\n  function button:__init(id)\n    hueResource.__init(self,id)\n  end\n  function button:button_state()\n    return self.rsrc.button and self.rsrc.button.last_event,self.rsrc.metadata.control_id\n  end\n  function button:__tostring()\n    return fmt(\"[button:%s,%s,value:%s]\",self.id,self:getName(\"BTN\"),self:button_state())\n  end\n  \n  \n  props.relative_rotary = {\n    relative_rotary = {\n      get=function(r) if r.relative_rotary then return r.relative_rotary.last_event end end,\n      set=function(r,v) if not r.relative_rotary then r.relative_rotary = { last_event = v } else r.relative_rotary.last_event=v end end,\n      changed=function(o,n)\n        local ob,nb = o.relative_rotary or {},n.relative_rotary or {}\n        return true,nb.last_event\n      end\n    }\n  }\n  local relative_rotary = classs('relative_rotary',hueResource)\n  function relative_rotary:__init(id)\n    hueResource.__init(self,id)\n  end\n  function relative_rotary:relative_rotary_state()\n    local le = self.rsrc.relative_rotary and self.rsrc.relative_rotary.last_event\n    if le then \n      return le.rotation.steps,le.rotation.direction \n    else return \"N\/A\",\"N\/A\" end\n  end\n  function relative_rotary:__tostring()\n    return fmt(\"[rotary:%s,%s,value:%s\/%s]\",self.id,self:getName(\"ROT\"),self:relative_rotary_state())\n  end\n  \n  props.temperature = {\n    temperature={\n      get=function(r) return r.temperature.temperature_report.temperature end,\n      set=function(r,v) r.temperature.temperature_report.temperature=v end,\n      changed=function(o,n) return o.temperature.temperature_report.temperature~=n.temperature.temperature_report.temperature,n.temperature.temperature_report.temperature end,\n    },\n  }\n  \n  local temperature = classs('temperature',hueResource)\n  function temperature:__init(id)\n    hueResource.__init(self,id)\n  end\n  function temperature:temperature()\n    return self.rsrc.temperature.temperature_report.temperature\n  end\n  function temperature:__tostring()\n    return fmt(\"[temperature:%s,%s,value:%s]\",self.id,self:getName(),self:temperature())\n  end\n  \n  props.motion = {\n    motion={\n      get=function(r) return r.motion.motion_report.motion end,\n      set=function(r,v) r.motion.motion_report.motion=v end,\n      changed=function(o,n) return o.motion.motion_report.motion~=n.motion.motion_report.motion,n.motion.motion_report.motion end\n    },\n  }\n  local motion = classs('motion',hueResource)\n  function motion:__init(id)\n    hueResource.__init(self,id)\n  end\n  function motion:motion()\n    return self.rsrc.motion.motion\n  end\n  function motion:__tostring()\n    return fmt(\"[motion:%s,%s,value:%s]\",self.id,self:getName(),self:motion())\n  end\n  \n  props.camera_motion = {\n    motion={\n      get=function(r) return (r.motion.motion_report or {}).motion or false end,\n      set=function(r,v) r.motion.motion_report.motion=v end,\n      changed=function(o,n) return o.motion.motion_report.motion~=n.motion.motion_report.motion,n.motion.motion_report.motion end\n    },\n  }\n  local camera_motion = classs('camera_motion',hueResource)\n  function camera_motion:__init(id)\n    hueResource.__init(self,id)\n  end\n  function camera_motion:motion()\n    return (self.rsrc.motion.motion_report or {}).motion or false\n  end\n  function camera_motion:__tostring()\n    return fmt(\"[camera_motion:%s,%s,value:%s]\",self.id,self:getName(),self:motion())\n  end\n  \n  props.light_level = {\n    light={\n      get=function(r) return (r.light.light_level_report or {}).light_level or 0 end,\n      set=function(r,v) r.light.light_level_report.light_level=v end,\n      changed=function(o,n) return o.light.light_level_report.light_level~=n.light.light_level_report.light_level,n.light.light_level_report.light_level end,\n    },\n  }\n  local light_level = classs('light_level',hueResource)\n  function light_level:__init(id)\n    hueResource.__init(self,id)\n  end\n  function light_level:light_level()\n    return (self.rsrc.light.light_level_report or {}).light_level or 0\n  end\n  function light_level:__tostring()\n    return fmt(\"[light_level:%s,%s,value:%s]\",self.id,self:getName(),self:light_level())\n  end\n  \n  local bridge = classs('bridge',hueResource)\n  function bridge:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[bridge:%s]\",self.id)\n  end\n  \n  local bridge_home = classs('bridge_home',hueResource)\n  function bridge_home:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[bridge_home:%s]\",self.id)\n  end\n  \n  local behavior_script = classs('behavior_script',hueResource)\n  function behavior_script:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[behavior_script:%s,%s,%s]\",self.id,self.rsrc.metadata.name,self.rsrc.metadata.category)\n  end\n  \n  local behavior_instance = classs('behavior_instance',hueResource)\n  function behavior_instance:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[behavior_instance:%s,%s,%s]\",self.id,self.rsrc.metadata.name,self.rsrc.metadata.category)\n  end\n  \n  local geolocation = classs('geolocation',hueResource)\n  function geolocation:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[geolocation:%s]\",self.id)\n  end\n  \n  local geofence_client = classs('geofence_client',hueResource)\n  function geofence_client:__init(id)\n    hueResource.__init(self,id)\n    self._str = fmt(\"[geofence_client:%s]\",self.id)\n  end\n  \n  local fetchEvents\n  local function handle_events(data)\n    for _,e1 in ipairs(data) do\n      if e1.type=='update' then\n        for _,r in ipairs(e1.data) do\n          local d = resources.get(r.id)\n          if d and d.event then\n            DEBUG('all_event',\"Event id:%s type:%s\",d.id,d.type)\n            d:annotateEvent(r)\n            d:event(r)\n          else\n            local _ = 0\n            if debug.unknownType then WARNING(\"Unknow resource type: %s\",json.encode(e1)) end\n          end\n        end\n      elseif e1.type == 'delete' then\n        for _,r in ipairs(e1.data) do\n          resources.changeHook()\n          resources.delete(r.id)\n        end\n      elseif e1.type == 'add' then\n        for _,r in ipairs(e1.data) do\n          resources.changeHook()\n          resources.add(r.id,r)\n        end\n      else\n        DEBUG('v2api',\"New v2 event type: %s\",e1.type)\n        DEBUG('v2api',\"%s\",json.encode(e1))\n      end\n    end\n  end\n  \n  local function fetchEvents_emu()\n    local getw\n    local eurl = url..\"\/eventstream\/clip\/v2\"\n    local args = { options = { \n      method='GET', \n      checkCertificate=false, \n      headers={ \n        ['hue-application-key'] = app_key,\n        ['Accept'] = \"application\/json\",\n      }}\n    }\n    function args.success(res)\n      local data = json.decode(res.data)\n      handle_events(data)\n      getw()\n    end\n    function args.error(err) if err~=\"timeout\" and err~=\"wantread\" then ERROR(\"\/eventstream: %s\",err) end getw() end\n    function getw() net.HTTPClient():request(eurl,args) end\n    setTimeout(getw,0)\n  end\n  \n  local function fetchEvents_hc3()\n    local getw\n    local eurl = url..\"\/eventstream\/clip\/v2\"\n    local args = {\n      options = { \n        method='GET', \n        checkCertificate=false,\n        headers={\n          [\"hue-application-key\"] = app_key, \n          ['Accept'] = \"text\/event-stream\" \n        },\n        timeout = 2000 \n      }\n    }\n    function args.success(res)\n      local stat,res = pcall(function()\n        if res.data:match(\"^: hi\") then res.data=\"[]\"\n        else res.data = res.data:match(\"(%b[])\") end\n        local data = json.decode(res.data)\n        handle_events(data)\n      end)\n      if not stat then print(\"ERR\",res) getw() end\n    end\n    function args.error(err) if err~=\"timeout\" and err~=\"wantread\" then ERROR(\"\/eventstream: %s\",err) end getw() end\n    function getw() net.HTTPClient():request(eurl,args) end\n    setTimeout(getw,0)\n  end\n  \n  if fibaro.fibemu then fetchEvents = fetchEvents_emu\n  else fetchEvents = fetchEvents_hc3 end\n  \n  function hueGET(api,event)\n    local u = url..api\n    net.HTTPClient():request(u,{\n      options = { \n        method='GET',\n        checkCertificate=false, \n        headers={ \n          ['hue-application-key'] = app_key,\n          [\"Accept\"] = \"application\/json\",\n        }\n      },\n      success = function(res) \n        if res.status < 300 then\n          post({type=event,result=json.decode(res.data)}) \n        else\n          post({type=event,error=res.status}) \n        end\n      end,\n      error = function(err) post({type=event,error=err})  end,\n    })\n  end\n  \n  function huePUT(path,data,op)\n    DEBUG('call',\"%s %s\",path,json.encode(data))\n    net.HTTPClient():request(url..path,{\n      options = {\n        method=op or 'PUT', \n        data=data and json.encode(data) or nil,\n        checkCertificate=false, \n        ['content-type']=\"application\/json\",\n        headers={ ['hue-application-key'] = app_key }\n      },\n      success = function(resp)\n        local b = resp\n      end,\n      error = function(err,f,g)\n        ERROR(\"hue call, %s %s - %s\",path,json.encode(data),err)\n      end,\n    })\n  end\n  \n  --[[\n  {\n  \"dimming\":{\"brightness\":58.66}, \/\/ color,color_temperature,on\n  \"owner\":{\"rtype\":\"device\",\"rid\":\"8dddf049-0a73-44e2-8fdd-e3c2310c1bb1\"},\n  \"type\":\"light\",\n  \"id_v1\":\"\/lights\/5\",\n  \"id\":\"fb31c148-177b-4b52-a1a5-e02d46c1c3dd\"\n  }\n  \n  {\n  \"id_v1\":\"\/groups\/5\",\n  \"type\":\"grouped_light\",\n  \"on\":{\"on\":true},\n  \"id\":\"39c94b33-7a3d-48e7-8cc1-dc603d401db2\"\n  }\n  \n  {\n  \"id\":\"efc3283b-304f-4053-a01a-87d0c51462c3\",\n  \"owner\":{\"rtype\":\"device\",\"rid\":\"a007e50b-0bdd-4e48-bee0-97636d57285a\"},\n  \"button\":{\"last_event\":\"initial_press\"}, \n  \"id_v1\":\"\/sensors\/2\",\n  \"type\":\"button\"\n  }\n  \n  {\n  \"type\":\"light_level\",\n  \"light\":{\"light_level\":0,\"light_level_valid\":true},\n  \"owner\":{\"rtype\":\"device\",\"rid\":\"9222ea53-37a6-4ac0-b57d-74bca1cfa23f\"},\n  \"id_v1\":\"\/sensors\/7\",\n  \"id\":\"a7295dae-379b-4d61-962f-6f9ad9426eda\"\n  }\n  \n  {\n  \"type\":\"motion\",\n  \"motion\":{\"motion\":false,\"motion_valid\":true},\n  \"owner\":{\"rtype\":\"device\",\"rid\":\"9222ea53-37a6-4ac0-b57d-74bca1cfa23f\"},\n  \"id_v1\":\"\/sensors\/6\",\"id\":\"6356a5c3-e5b7-455c-bf54-3af2ac511fe6\"\n  }\n  \n  {\n  \"type\":\"device_power\",\n  \"power_state\":{\"battery_state\":\"normal\",\"battery_level\":76},\n  \"owner\":{\"rtype\":\"device\",\"rid\":\"a007e50b-0bdd-4e48-bee0-97636d57285a\"},\n  \"id_v1\":\"\/sensors\/2\",\n  \"id\":\"d6bc1f77-4603-4036-ae5f-28b16eefe4b5\"\n  }\n  \n  {\n  \"type\":\"zigbee_connectivity\",\n  \"owner\":{\"rtype\":\"device\",\"rid\":\"3ab27084-d02f-44b9-bd56-70ea41163cb6\"},\n  \"status\":\"connected\",  \/\/ \"status\":\"connectivity_issue\"\n  \"id_v1\":\"\/lights\/9\",\n  \"id\":\"c024b020-395d-45a4-98ce-9df1409eda30\"\n  }\n  --]]\n  \n  ---------------------------------------------------------------------------\n  \n  fibaro.event({type='STARTUP'},function(_) hueGET(\"\/api\/config\",'HUB_VERSION') end)\n  \n  fibaro.event({type='HUB_VERSION'},function(ev)\n    if ev.error then\n      ERROR(\"%s\",ev.error)\n    else\n      resources = createResourceTable()\n      local res = ev.result\n      if res.swversion >= v2 then\n        DEBUG('info',\"V2 api available (%s)\",res.swversion)\n        post({type='REFRESH_RESOURCES'})\n      else\n        WARNING(\"V2 api not available (%s)\",res.swversion)\n      end\n    end\n  end)\n  \n  fibaro.event({type='REFRESH_RESOURCES'},function(_) hueGET(\"\/clip\/v2\/resource\",'REFRESHED_RESOURCES') end)\n  \n  fibaro.event({type='REFRESHED_RESOURCES'},function(ev)\n    if ev.error then\n      ERROR(\"\/clip\/v2\/resource %s\",ev.error)\n      ERROR(\"Retry in %ss\",err_retry)\n      post({type='REFRESH_RESOURCES'},1000*err_retry)\n      return\n    end\n    for _,r in pairs(resources.id2resource) do\n      r._dirty = true\n    end\n    for _,r in ipairs(ev.result.data or {}) do\n      --print(r.type)\n      r._dirty=nil\n      resources.add(r.id,r)\n    end\n    for _,r in pairs(resources.id2resource) do\n      if r._dirty then\n        resources.delete(r.id)\n      end\n    end\n    local cb\n    if callBack then cb,callBack=callBack,nil setTimeout(cb,0) end\n  end)\n  \n  function HUEv2Engine:getResources() return resources.resources end\n  function HUEv2Engine:getResourceIds() return resources.id2resource end\n  function HUEv2Engine:getResource(id) return resources.id2resource[id] end\n  function HUEv2Engine:getResourceType(typ) return resources.resources[typ] or {} end\n  function HUEv2Engine:_resolve(id) return resolve(id) end\n  function HUEv2Engine:getSceneByName(name,roomzone)\n    local scenes = self:getResourceType('scene')\n    for id,scene in pairs(scenes) do\n      if scene.name == name then\n        if not roomzone then return scene end\n        local g = scene.rsrc.group and resolve(scene.rsrc.group) or {}\n        if g.name == roomzone then return scene end\n      end\n    end\n  end\n  local filter1 = { device=1, scene=10, room=2, zone=3 }\n  \n  local filter2 = { device=1, light=4, button=5, relative_rotary=5.5, scene=10, room=2, zone=3, temperature=6, light_level=7, motion=8, tamper=7.5, contact=7.6, grouped_light=9, zigbee_connectivity=10, device_power=11 }\n  \n  local function printBuffer(init) \n    local b = {init}\n    function b:add(s) b[#b+1]=s end\n    function b:printf(fmt,...) b:add(fmt:format(...)) end\n    function b:tostring() return table.concat(b) end\n    return b\n  end\n  fibaro.printBuffer = printBuffer\n  \n  function HUEv2Engine:dumpDeviceTable(filter,selector,orgDevMap)\n    filter =filter and filter2 or filter1\n    orgDevMap = orgDevMap or {}\n    selector = selector or function() return true end\n    local  pb = printBuffer(\"\\n\")\n    pb:add(\"\\nlocal HueDeviceTable = {\\n\")\n    local rs = {}\n    for _,r in pairs(HUEv2Engine:getResourceIds()) do\n      if filter[r.type] then\n        rs[#rs+1]={order=filter[r.type],str=tostring(r),r=r}\n      end\n    end\n    local parentMap = {room={},zone={}}\n    for _,r0 in ipairs(rs) do\n      local r = r0.r\n      if r.type=='room' or r.type=='zone' then\n        for _,c in ipairs(r.children) do\n          parentMap[r.type][c.rid]=r.name\n        end\n      end\n    end\n    table.sort(rs,function(a,b) return a.order < b.order or a.order==b.order and a.str < b.str end)\n    for _,r0 in ipairs(rs) do\n      local r = r0.r\n      local room = parentMap.room[r.id]\n      local zone = parentMap.zone[r.id]\n      local ref = (orgDevMap[r.id] or {}).ref\n      room=room and (\",room='\"..room..\"'\") or \"\"\n      zone=zone and (\",zone='\"..zone..\"'\") or \"\"\n      ref=ref and (\",ref='\"..ref..\"'\") or \"\"\n      if r.type=='scene' then\n        room = (\",room='\"..resolve(r.rsrc.group).name..\"'\")\n      end\n      pb:printf(\"%s['%s']={type='%s',name='%s',model='%s'%s%s%s},\\n\",selector(r.id) and \"  \" or \"--\",r.id,r.type,r.name,r.resourceType,room,zone,ref)\n    end\n    pb:add(\"}\\n\")\n    print(pb:tostring())\n  end\n  \n  function HUEv2Engine:createDeviceTable(filter)\n    filter =filter and filter2 or filter1\n    local rs,rs2,res = HUEv2Engine:getResourceIds(),{},{}\n    \n    local parentMap = {room={},zone={}}\n    for uid,r in pairs(rs) do\n      if filter[r.type] then\n        rs2[uid]=r\n        if r.type=='room' or r.type=='zone' then\n          for _,c in ipairs(r.children) do\n            parentMap[r.type][c.rid]=r.name\n          end\n        end\n      end\n    end\n    for uid,r in pairs(rs2) do\n      local m = {}\n      res[uid]=m\n      m.room = parentMap.room[r.id]\n      m.zone = parentMap.zone[r.id]\n      if r.type=='scene' then\n        m.room = resolve(r.rsrc.group).name\n      end\n      m.type=r.type\n      m.name=r.name\n      m.model=r.resourceType\n      m.props=strip(r:getProps())\n      local btns=0\n      if r.services then\n        for _,s in ipairs(r.services) do\n          btns = btns + (s.rtype=='button' and 1 or 0)\n        end\n      end\n      m.buttons=btns\n    end\n    return res\n  end\n  \n  local function sortResources(list,f)\n    local rs = {}\n    for _,r in pairs(list) do\n      r = f and f(r) or r\n      if filter2[r.type] then\n        rs[#rs+1]={order=filter2[r.type],resource=r}\n      end\n    end\n    table.sort(rs,function(a,b) return a.order < b.order or a.order==b.order and a.resource.id < b.resource.id end)\n    local r0 = {}\n    for _,r in ipairs(rs) do r0[#r0+1]=r.resource end\n    return r0\n  end\n  \n  local function printResource(r,pb,ind)\n    pb:add(string.rep(' ',ind)..tostring(r)..\"\\n\")\n    if r.owner then pb:add(string.rep(' ',ind+2)..\"Parent:\"..r.owner.rid..\"\\n\") end\n    local rs = r.children and sortResources(r.children,function(r) return resolve(r) end) or {}\n    if rs[1] then\n      pb:add(string.rep(' ',ind+2)..\"Children:\\n\")\n      for _,c in ipairs(rs) do\n        printResource(c,pb,ind+4)\n      end\n    end\n    rs = r.services and sortResources(r.services,function(r) return resolve(r) end) or {}\n    if rs[1] then\n      pb:add(string.rep(' ',ind+2)..\"Services:\\n\")\n      for _,c in ipairs(rs) do\n        printResource(c,pb,ind+4)\n      end\n    end\n    if r.rsrc.actions then\n      local w = resolve(r.rsrc.group)\n      pb:add(string.rep(' ',ind+2)..\"Group:\"..tostring(w)..\"\\n\")\n      pb:add(string.rep(' ',ind+2)..\"Targets:\\n\")\n      for _,a in ipairs(r.rsrc.actions or {}) do\n        local f = resolve(a.target)\n        pb:add(string.rep(' ',ind+4)..tostring(f)..\"\\n\")\n      end\n    end\n  end\n  \n  function HUEv2Engine:listAllDevicesGrouped(groups)\n    local  pb = printBuffer(\"\\n\")\n    pb:add(\"------------------------\\n\")\n    local rs = sortResources(HUEv2Engine:getResourceIds())\n    for _,r in ipairs(rs) do if not r.owner then printResource(r,pb,0) end end\n    pb:add(\"------------------------\\n\")\n    print(pb:tostring():gsub(\"\\n\",\"<\/br>\"):gsub(\"%s\",\"&nbsp;\"))\n  end\n  \n  function _initEngine(ip,key,cb)\n    app_key = key\n    url =  fmt(\"https:\/\/%s:443\",ip)\n    DEBUG('info',\"HUEv2Engine v%s\",version)\n    DEBUG('info',\"Hub url: %s\",url)\n    callBack = function() fetchEvents() if cb then cb() end end\n    post({type='STARTUP'})\n  end\n  \nend -- main()\n\nfunction HUEv2Engine:init(ip,key,cb) \n  setup() \n  main() \n  _initEngine(ip,key,cb)\nend\n","isOpen":false,"name":"Engine"},{"isMain":false,"type":"lua","content":"---@diagnostic disable: undefined-global\n------- QAs\/HueV2App.lua ----------\nfibaro.debugFlags = fibaro.debugFlags or {}\nlocal HUE\n\nlocal _version = 0.59\nlocal serial = \"UPD896661234567893\"\nHUEv2Engine = HUEv2Engine or {}\nlocal HUE = HUEv2Engine\nHUE.appName = \"YahueV2\"\nHUE.appVersion = tostring(_version)\n\nlocal function ROUND(i) return math.floor(i+0.5) end\nlocal function printf(fmt,...) print(string.format(fmt,...)) end\nlocal function keys(t) local r = {} for k,v in pairs(t) do r[#r+1]=k end return r end\nlocal function values(t) local r = {} for k,v in pairs(t) do r[#r+1]=v end return r end\nlocal argsMap = {}\nlocal function getVar(id,key)\n  local res, stat = api.get(\"\/plugins\/\" .. id .. \"\/variables\/\" .. key)\n  if stat ~= 200 then return nil end\n  return res.value\nend\n\nlocal devProps = {\n  temperature = \"TemperatureSensor\",\n  relative_rotary = \"MultilevelSensor\",\n  button = \"Button\",\n  light = \"LuxSensor\",\n  contact_report = \"DoorSensor\",\n  motion = \"MotionSensor\",\n  [function(p) return p.on and not (p.color or p.dimming) and \"plug\" end] = \"BinarySwitch\",\n}\n\nlocal defClasses\n\nfunction HUEv2Engine:app()\n  defClasses()\n  local childDevices = {}\n  for _,c in ipairs(api.get(\"\/devices?parentId=\"..quickApp.id) or {}) do\n    local uid = getVar(c.id,\"ChildID\")\n    if uid then childDevices[uid]=true end\n  end\n  --print(json.encode(childDevices))\n  local ddevices = {}\n  for id,dev in pairs(HUE:getResourceType('device')) do\n    dev = HUE:getResource(id)\n    local props,ok = dev:getProps()\n    for p,cls in pairs(devProps) do\n      if type(p) == 'function' then ok = p(props)\n      else ok = props[p] and p end\n      if ok then\n        print(ok,\"->\",dev.name)\n        local tag = cls..\":\"..id\n        ddevices[tag] = {\n          name = dev.name,\n          id = id,\n          class = cls,\n          enabled = childDevices[tag] or false,\n          args = {}\n        }\n      end\n    end\n  end\n  for id,zr in pairs(HUE:getResourceType('zone')) do\n    local tag = \"RoomZoneQA:\"..id\n    ddevices[tag] = {\n      name = zr.name or tag,\n      id = id,\n      class = \"RoomZoneQA\",\n      enabled = childDevices[tag] or false,\n      args = {}\n    }\n  end\n  for id,zr in pairs(HUE:getResourceType('room')) do\n    local tag = \"RoomZoneQA:\"..id\n    ddevices[tag] = {\n      name = zr.name or tag,\n      id = id,\n      class = \"RoomZoneQA\",\n      enabled = childDevices[tag] or false,\n      args = {}\n    }\n  end\n  \n  local hdevs = {}\n  for _,d in ipairs(HUEDevices) do\n    hdevs[d.class..\":\"..d.id] = d\n  end\n  \n  local regenerate = false\n  for id,_ in pairs(hdevs) do\n    if (not hdevs[id].name) or (not ddevices[id]) then hdevs[id] = nil regenerate=true end\n  end\n  for id,dev in pairs(ddevices) do\n    if not hdevs[id] then hdevs[id] = dev regenerate=true end\n  end\n  \n  local function encodeArgs(t)\n    if type(t)~='table' then return \"{}\" end\n    local p = fibaro.printBuffer()\n    for k,v in pairs(t) do\n      p:printf(\"%s='%s',\",k,tostring(v))\n    end\n    return \"{\"..p:tostring()..\"}\"\n  end\n  \n  if regenerate then\n    print(\"Regenerating map file\")\n    local b = fibaro.printBuffer()\n    local hhdevs = values(hdevs)\n    table.sort(hhdevs,function(a,b) return a.id < b.id end)\n    b:printf(\"\\nHUEDevices = {\\n\")\n    local i = \"\"\n    for _,dev in pairs(hhdevs) do\n      local d = HUE:getResource(dev.id)\n      if d.id ~= i then\n        b:printf(\"-- '%s', %s\\n\",d.name,d.resourceName or \"<N\/A\")\n        i = d.id\n      end\n      b:printf(\" {id='%s', name='%s', class='%s', enabled=%s, args=%s},\\n\",dev.id,dev.name,dev.class,dev.enabled,encodeArgs(dev.args))\n    end\n    \n    b:printf(\"}\\n\")\n    print(b:tostring())\n    \n    if fibaro.fibemu then\n      local data = b:tostring()\n      local f = io.open(\"QAs\/HueV2Map.lua\",\"w\")\n      if f then\n        f:write(data)\n        f:close()\n      end\n      data = \"return function() \"..data..\" return HUEDevices end\"\n      HUEDevices = load(data)()()\n    else\n      if not api.put(\"\/quickApp\/\"..quickApp.id..\"\/files\/Map\",{\n        name=\"Map\", isMain=false, isOpem=false, content=b:tostring()\n      }) then\n        api.post(\"\/quickApp\/\"..quickApp.id..\"\/files\",{\n          name=\"Map\", isMain=false, isOpem=false, content=b:tostring()\n        })\n      end\n    end\n    hdevs = {}\n    for _,d in ipairs(HUEDevices) do\n      hdevs[d.class..\":\"..d.id] = d\n    end\n  end\n  \n  local children = {}\n  for id,data in pairs(hdevs) do\n    argsMap[id]=data\n    if data.enabled then\n      local dev = HUE:getResource(data.id)\n      children[id] = {\n        name = dev.name,\n        type = data.type or _G[data.class].htype,\n        className = data.class,\n        interfaces = dev:getProps()['power_state'] and {'battery'} or nil,\n      }\n      if true then\n        _G[data.class].annotate(children[id])\n      end\n    end\n  end\n  \n  quickApp:initChildren(children)\nend\n\nfunction defClasses()\n  print(\"Defining QA classes\")\n  \n  class 'HueClass'(QwikAppChild)\n  function HueClass:__init(dev)\n    QwikAppChild.__init(self,dev)\n    self.uid = self._uid:match(\".-:(.*)\")\n    self.dev = HUE:getResource(self.uid)\n    self.pname = \"CHILD\"..self.id\n    local props = self.dev:getProps()\n    self.dev:subscribe(\"status\",function(key,value,b)\n      self:print(\"status %s\",value)\n      if value ~= 'connected' then\n        self:updateProperty(\"dead\",true)\n      end\n      self:updateProperty(\"dead\",value~='connected')\n    end)\n    self.dev:subscribe(\"power_state\",function(key,value,b)\n      self:print(\"battery %s\",value.battery_level)\n      self:updateProperty(\"batteryLevel\",value.battery_level)\n    end)\n    if self.properties.userDescription == nil or self.properties.userDescription == \"\" then\n      local fmt = string.format\n      local d = fmt(\"%s\\n%s\",self.dev.type,self.dev.id)\n      print(d)\n      if self.dev.product_data then\n        local pd = self.dev.product_data\n        d = d..fmt(\"\\n%s\\n%s\",pd.product_name or \"\",pd.model_id or \"\")\n      end\n      self:updateProperty(\"userDescription\",d)\n    end\n  end\n  function HueClass:print(fmt,...)\n    local TAG = __TAG; __TAG = self.pname\n    self:debug(string.format(fmt,...))\n    __TAG = TAG\n  end\n  \n  class 'TemperatureSensor'(HueClass)\n  TemperatureSensor.htype = \"com.fibaro.temperatureSensor\"\n  function TemperatureSensor:__init(device)\n    HueClass.__init(self,device)\n    self.dev:subscribe(\"temperature\",function(key,value,b)\n      self:print(\"temperature %s\",value)\n      self:updateProperty(\"value\",value)\n    end)\n    self.dev:publishAll()\n  end\n  function TemperatureSensor.annotate() end\n  \n  class 'BinarySwitch'(HueClass)\n  BinarySwitch.htype = \"com.fibaro.binarySwitch\"\n  function BinarySwitch:__init(device)\n    HueClass.__init(self,device)\n    self.dev:subscribe(\"on\",function(key,value,b)\n      self:print(\"on %s\",value)\n      self:updateProperty(\"value\",value)\n    end)\n    self.dev:publishAll()\n  end\n  function BinarySwitch:turnOn()\n    self:updateProperty(\"value\",true)\n    self:updateProperty(\"state\",true)\n  end\n  function BinarySwitch:turnOff()\n    self:updateProperty(\"value\",false)\n    self:updateProperty(\"state\",false)\n  end\n  function BinarySwitch.annotate() end\n  \n  class 'LuxSensor'(HueClass)\n  LuxSensor.htype = \"com.fibaro.lightSensor\"\n  function LuxSensor:__init(device)\n    HueClass.__init(self,device)\n    self.dev:subscribe(\"light\",function(key,value,b)\n      value = 10 ^ ((value - 1) \/ 10000)\n      self:print(\"lux %s\",value)\n      self:updateProperty(\"value\",value)\n    end)\n    self.dev:publishAll()\n  end\n  function LuxSensor.annotate() end\n  \n  class 'MotionSensor'(HueClass)\n  MotionSensor.htype = \"com.fibaro.motionSensor\"\n  function MotionSensor:__init(device)\n    HueClass.__init(self,device)\n    self.dev:subscribe(\"motion\",function(key,value,b)\n      self:print(\"motion %s\",value)\n      self:updateProperty(\"value\",value)\n    end)\n    self.dev:publishAll()\n  end\n  function MotionSensor.annotate() end\n  \n  local btnMap = {\n    initial_press=\"Pressed\",\n    ['rep'..'eat']=\"HeldDown\",\n    short_release=\"Released\",\n    long_release=\"Released\"\n  }\n  class 'Button'(HueClass)\n  Button.htype = 'com.fibaro.remoteController'\n  function Button:__init(device)\n    HueClass.__init(self,device)\n    local deviceId,ignore = self.id,false\n    local btnSelf = self\n    local buttons = {}\n    self.dev:subscribe(\"button\",function(key,value,b)\n      local _modifier,key = b:button_state()\n      b._props.button.set(b.rsrc,\"_\")\n      local modifier = btnMap[_modifier] or _modifier\n      local function action(r)\n        btnSelf:print(\"button:%s %s %s\",key,modifier,_modifier)\n        local data = {\n          type =  \"centralSceneEvent\",\n          source = deviceId,\n          data = { keyAttribute = modifier, keyId = key }\n        }\n        if not ignore then api.post(\"\/plugins\/publishEvent\", data) end\n        btnSelf:updateProperty(\"log\",string.format(\"Key:%s,Attr:%s\",key,modifier))\n        if r and not ignore then\n          btnSelf:print(\"button:%s %s\",key,\"Released\")\n          data.data.keyAttribute = \"Released\"\n          api.post(\"\/plugins\/publishEvent\", data)\n          btnSelf:updateProperty(\"log\",string.format(\"Key:%s,Attr:%s\",key,\"Released\"))\n        end\n      end\n      if modifier == 'Pressed' then\n        local bd = buttons[key] or {click=0}; buttons[key] = bd\n        if bd.ref then clearTimeout(bd.ref) end\n        bd.click = bd.click + 1\n        bd.ref = setTimeout(function()\n          buttons[key] = nil\n          if bd.click > 1 then modifier = modifier..bd.click end\n          action(true)\n        end,1500)\n      elseif modifier == 'Released' then\n      else action() end\n    end)\n    ignore = true\n    self.dev:publishAll()\n    ignore = false\n  end\n  function Button.annotate(child)\n    child.properties = child.properties or {}\n    child.properties.centralSceneSupport = {\n      { keyAttributes = {\"Pressed\",\"Released\",\"HeldDown\",\"Pressed2\",\"Pressed3\"},keyId = 1 },\n      { keyAttributes = {\"Pressed\",\"Released\",\"HeldDown\",\"Pressed2\",\"Pressed3\"},keyId = 2 },\n      { keyAttributes = {\"Pressed\",\"Released\",\"HeldDown\",\"Pressed2\",\"Pressed3\"},keyId = 3 },\n      { keyAttributes = {\"Pressed\",\"Released\",\"HeldDown\",\"Pressed2\",\"Pressed3\"},keyId = 4 },\n    }\n    child.interfaces = child.interfaces or {}\n    table.insert(child.interfaces,\"zwaveCentralScene\")\n  end\n  \n  class 'DoorSensor'(HueClass)\n  DoorSensor.htype = \"com.fibaro.doorSensor\"\n  function DoorSensor:__init(device)\n    HueClass.__init(self,device)\n    self.dev:subscribe(\"contact_report\",function(key,value,b)\n      value = not(value=='contact')\n      self:print(\"contact %s\",value)\n      self:updateProperty(\"value\",value)\n    end)\n    self.dev:publishAll()\n  end\n  function DoorSensor.annotate() end\n  \n  class 'MultilevelSensor'(HueClass)\n  MultilevelSensor.htype = \"com.fibaro.multilevelSensor\"\n  function MultilevelSensor:__init(device)\n    HueClass.__init(self,device)\n    self.args = argsMap[self._uid].args or {}\n    self.args.div = self.args.div or 1\n    self.value = 0\n    self.dev:subscribe(\"relative_rotary\",function(key,v,b)\n      if not v then return end\n      local steps = math.max(ROUND(v.rotation.steps \/ self.args.div),1)\n      local dir = (1 - (v.rotation.direction=='clock_wise' and 0 or 2))\n      self.value = self.value + steps*dir\n      if self.value < 0 then self.value = 0 end\n      if self.value > 100 then self.value = 100 end\n      self:print(\"rotary %s\",self.value)\n      self:updateProperty(\"value\",self.value)\n    end)\n    self.dev:publishAll()\n  end\n  function MultilevelSensor.annotate(rsrc)\n  end\n  \n  class 'RoomZoneQA'(HueClass)\n  RoomZoneQA.htype = \"com.fibaro.multilevelSwitch\"\n  function RoomZoneQA:__init(device)\n    HueClass.__init(self,device)\n    self.args = argsMap[self._uid].args or {}\n    self.args.dimdelay = self.args.dimdelay or 8000\n    \n    -- Check room\/zone dead status\n    local statuses = {}\n    local devsons = {}\n    for _,c in pairs(self.dev.children or {}) do\n      c = HUE:_resolve(c)\n      if c.type ~= 'device' then\n        c = HUE:_resolve(c.owner)\n      end\n      local props = c:getProps()\n      --if props.status then\n      statuses[c.id] = true\n      c = HUE:getResource(c.id)\n      c:subscribe(\"status\",function(key,value,b)\n        statuses[b.id] = value == 'connected'\n        local stat = true\n        for _,s in pairs(statuses) do stat=stat and s end\n        local oldDead = fibaro.getValue(self.id,'dead')\n        self:updateProperty(\"dead\",not stat)\n        local state = fibaro.getValue(self.id,'state')\n        local value = fibaro.getValue(self.id,'value')\n        if (not stat) ~= oldDead then -- change in dead state\n           if not stat then -- Now dead\n              self.deadStatus = {state,value}\n              self:updateProperty('state',false)\n              self:updateProperty('value',0)\n           else -- Now living\n              if self.deadStatus then\n                self:updateProperty('state',self.deadStatus[1])\n                self:updateProperty('value',self.deadStatus[2])\n              end\n           end\n        end\n        self:print(\"status %s\",stat)\n      end)\n      c:subscribe(\"on\",function(key,value,b)\n        devsons[b.id] = value\n        print(\"c on\",value,b.id)\n        for _,s in pairs(devsons) do\n          --\n        end\n      end)\n      local c0 = c\n      setTimeout(function()\n        c0:publishAll()\n      end,0)\n      --end\n    end\n    \n    self.dev:subscribe(\"on\",function(key,value,b)\n      self:print(\"on %s\",value)\n      local d = ROUND(b._props.dimming.get(b.rsrc))\n      self:updateProperty(\"state\",value)\n      self:updateProperty(\"value\",d)\n    end)\n    \n    self.dev:subscribe(\"dimming\",function(key,value,b)\n      self:print(\"dimming %s\",value)\n      self:updateProperty(\"value\",ROUND(value))\n    end)\n    \n    self.dev:publishAll()\n  end\n  \n  function RoomZoneQA:setScene(event)\n    self:setVariable(\"scene\",event)\n  end\n  function RoomZoneQA:turnOn(sceneArg)\n    self:updateProperty(\"value\", 100)\n    self:updateProperty(\"state\", true)\n    local sceneName = type(sceneArg)=='string' and sceneArg or self:getVar(\"scene\")\n    \n    local scene = HUE:getSceneByName(sceneName,self.dev.name)\n    if sceneName and not scene then self:print(\"Scene %s not found\",sceneName) end\n    if not scene then\n      self.dev:targetCmd({on = {on=true}})\n    else\n      self:print(\"Turn on Scene %s\",scene.name)\n      scene:recall()\n    end\n  end\n  function RoomZoneQA:turnOff()\n    self:print(\"Turn off\")\n    self:updateProperty(\"value\", 0)\n    self:updateProperty(\"state\", false)\n    self.dev:targetCmd({on = {on=false}})\n  end\n  function RoomZoneQA:setValue(value)\n    if type(value)=='table' then value = value.values[1] end\n    value = tonumber(value)\n    self:print(\"setValue\")\n    self:updateProperty(\"value\", value)\n    self.dev:targetCmd({dimming = {brightness=value}})\n  end\n  function RoomZoneQA:startLevelIncrease()\n    self:print(\"startLevelIncrease\")\n    local val = self.properties.value\n    val = ROUND((100-val)\/100.0*self.args.dimdelay)\n    --self:print(\"LI %s %s\",self.properties.value,val)\n    self.dev:targetCmd({dimming = {brightness=100}, dynamics ={duration=val}})\n  end\n  function RoomZoneQA:startLevelDecrease()\n    self:print(\"startLevelDecrease\")\n    local val = self.properties.value\n    val = ROUND((val-0)\/100.0*self.args.dimdelay)\n    --self:print(\"LD %s %s\",self.properties.value,val)\n    self.dev:targetCmd({dimming = {brightness=0}, dynamics ={duration=val}})\n  end\n  function RoomZoneQA:stopLevelChange()\n    self.dev:targetCmd({dimming_delta = {action='stop'}})\n  end\n  function RoomZoneQA:getVar(name)\n    local qvs = __fibaro_get_device_property(self.id,\"quickAppVariables\").value\n    for _,var in ipairs(qvs or {}) do\n      if var.name==name then return var.value end\n    end\n    return nil\n  end\n  function RoomZoneQA.annotate(rsrc)\n    rsrc.interfaces = rsrc.interfaces or {}\n    table.insert(rsrc.interfaces,\"levelChange\")\n  end\n  \nend\n\n----------- Child class\ndo\n  local VERSION = \"1.0\"\n  print(\"QwikAppChild library v\"..VERSION)\n  local childID = 'ChildID'\n  local classID = 'ClassName'\n\n  local children = {}\n  local createChild = QuickApp.createChildDevice\n  function QuickApp:initChildDevices() end\n  QuickApp.debugQwikAppChild = true\n\n  class 'QwikAppChild'(QuickAppChild)\n\n  local fmt = string.format\n\n  local function getVar(deviceId,key)\n    local res, stat = api.get(\"\/plugins\/\" .. deviceId .. \"\/variables\/\" .. key)\n    if stat ~= 200 then return nil end\n    return res.value\n  end\n\n  local UID = nil\n  function QwikAppChild:__init(device)\n    QuickAppChild.__init(self, device)\n    local uid = UID or self:internalStorageGet(childID) or \"\"\n    self._uid = uid\n    children[uid]=self\n    self._sid = tonumber(uid:match(\"(%d+)$\"))\n  end\n\n  function QuickApp:createChildDevice0(uid,props,interfaces,className)\n    __assert_type(uid,'string')\n    __assert_type(className,'string')\n    props.initialProperties = props.initialProperties or {}\n    props.initialInterfaces = interfaces\n    UID = uid\n    local c = createChild(self,props,_G[className])\n    UID = nil\n    if not c then return end\n    c:internalStorageSet(childID,uid,true)\n    c:internalStorageSet(classID,className,true)\n    return c\n  end\n\n  function QuickApp:loadExistingChildren(chs)\n    __assert_type(chs,'table')\n    local rerr = false\n    local stat,err = pcall(function()\n      self.children = children\n      local cdevs,n = api.get(\"\/devices?parentId=\"..self.id) or {},0 -- Pick up all my children\n      for _,child in ipairs(cdevs) do\n        local uid = getVar(child.id,childID)\n        local className = getVar(child.id,classID)\n        local childObject = nil\n        if chs[uid] then\n          if QuickApp.debugQwikAppChild then\n            self:debug(fmt(\"Loading existing child UID:'%s'\",uid))\n          end\n          local stat,err = pcall(function()\n            childObject = _G[className] and _G[className](child) or QuickAppChild(child)\n            self.childDevices[child.id] = childObject\n            childObject.parent = self\n          end)\n          if not stat then\n            self:error(fmt(\"loadExistingChildren:%s child UID:%s\",err,uid))\n            rerr=true\n          end\n        end\n      end\n    end)\n    if not stat then rerr=true self:error(\"loadExistingChildren:\"..err) end\n    return rerr\n  end\n\n  function QuickApp:createMissingChildren(children)\n    local stat,err = pcall(function()\n      local chs,k = {},0\n      for uid,data in pairs(children) do\n        local m = uid:sub(1,1)=='i' and 100 or 0\n        k = k + 1\n        chs[#chs+1]={uid=uid,id=m+tonumber(uid:match(\"(%d+)$\") or k),data=data}\n      end\n      table.sort(chs,function(a,b) return a.id<b.id end)\n      for _,ch in ipairs(chs) do\n        if not self.children[ch.uid] then -- not loaded yet\n          if QuickApp.debugQwikAppChild then\n            self:debug(fmt(\"Creating missing child UID:'%s'\",ch.uid))\n          end\n          local props = {\n            name = ch.data.name,\n            type = ch.data.type,\n            initialProperties = ch.data.properties,\n          }\n          self:createChildDevice0(ch.uid,props,ch.data.interfaces,ch.data.className)\n        end\n      end\n    end)\n    if not stat then self:error(\"createMissingChildren:\"..err) end\n  end\n\n  function QuickApp:removeUndefinedChildren(children)\n    local cdevs = api.get(\"\/devices?parentId=\"..self.id)\n    for _,child in ipairs(cdevs) do\n      if not self.childDevices[child.id] then\n        if QuickApp.debugQwikAppChild then\n          self:debug(fmt(\"Deleting undefined child ID:%s\",child.id))\n        end\n        api.delete(\"\/plugins\/removeChildDevice\/\" .. child.id)\n      end\n    end\n  end\n\n  function QuickApp:initChildren(children)\n    if self:loadExistingChildren(children) then return end\n    self:createMissingChildren(children)\n    self:removeUndefinedChildren(children) -- Remove child devices not loaded\/created\n  end\nend","isOpen":false,"name":"App"},{"isMain":false,"type":"lua","content":"\nHUEDevices = {\n-- 'Stars', Zone\n {id='39e1fc25-e926-42e5-a840-b2d21aaa08f3', name='Stars', class='RoomZoneQA', enabled=false, args={}},\n-- 'Secure battery camera 1', Secure battery camera\n {id='77b1f0b8-8c20-428b-ba42-d4571bee137b', name='Secure battery camera 1', class='LuxSensor', enabled=false, args={}},\n {id='77b1f0b8-8c20-428b-ba42-d4571bee137b', name='Secure battery camera 1', class='MotionSensor', enabled=false, args={}},\n-- 'Guest room', Room\n {id='795959f5-9313-4aae-b930-b178b48249e0', name='Guest room', class='RoomZoneQA', enabled=false, args={}},\n-- 'Gymet', Zone\n {id='79e44c37-15e0-4d93-8d89-230b14822270', name='Gymet', class='RoomZoneQA', enabled=false, args={}},\n-- 'Hue tap dial switch 1', Hue tap dial switch\n {id='888cb832-5f11-46d0-b916-988ae158eeef', name='Hue tap dial switch 1', class='MultilevelSensor', enabled=false, args={}},\n {id='888cb832-5f11-46d0-b916-988ae158eeef', name='Hue tap dial switch 1', class='Button', enabled=false, args={}},\n-- 'Hue smart plug 1', Hue smart plug\n {id='8a453c82-0072-4223-9c42-f395b5cb0c40', name='Hue smart plug 1', class='BinarySwitch', enabled=false, args={}},\n-- 'Living room sensor', Hue motion sensor\n {id='9222ea53-37a6-4ac0-b57d-74bca1cfa23f', name='Living room sensor', class='MotionSensor', enabled=false, args={}},\n {id='9222ea53-37a6-4ac0-b57d-74bca1cfa23f', name='Living room sensor', class='TemperatureSensor', enabled=false, args={}},\n {id='9222ea53-37a6-4ac0-b57d-74bca1cfa23f', name='Living room sensor', class='LuxSensor', enabled=false, args={}},\n-- 'Living room wall switch', Hue wall switch module\n {id='932bd43b-d8cd-44bc-b8bd-daaf72ae6f82', name='Living room wall switch', class='Button', enabled=false, args={}},\n-- 'Kks', Room\n {id='9ab242fb-fae1-47e5-a54f-51bb8e80ac31', name='Kks', class='RoomZoneQA', enabled=false, args={}},\n-- 'Window lights', Zone\n {id='9bfda4bf-b17e-4ec9-9123-a97afbcca814', name='Window lights', class='RoomZoneQA', enabled=false, args={}},\n-- 'Dimmer switch', Hue dimmer switch\n {id='a007e50b-0bdd-4e48-bee0-97636d57285a', name='Dimmer switch', class='Button', enabled=false, args={}},\n-- 'Sovrums Star', Room\n {id='a8896574-f4a3-4e8a-af8e-737cfc262fc9', name='Sovrums Star', class='RoomZoneQA', enabled=false, args={}},\n-- 'Rest', Room\n {id='abc8b8fd-51f6-4ce9-9ad8-81d99806346f', name='Rest', class='RoomZoneQA', enabled=false, args={}},\n-- 'Kitchen island', Zone\n {id='b5f12b5f-20c7-47a5-8535-c7a20fb9e66d', name='Kitchen island', class='RoomZoneQA', enabled=false, args={}},\n-- 'Hall', Room\n {id='bbe472e6-8ea8-477b-a116-ca345452e056', name='Hall', class='RoomZoneQA', enabled=false, args={}},\n-- 'Living room', Room\n {id='bcd3daec-82a9-4de7-813a-3464beee0090', name='Living room', class='RoomZoneQA', enabled=false, args={}},\n-- 'Front Door', Hue secure contact sensor\n {id='c798b542-6910-487f-81c7-1804cc3a727f', name='Front Door', class='DoorSensor', enabled=false, args={}},\n-- 'Bedroom', Room\n {id='cc309f30-d0f4-4ab5-a31f-39cd2206be57', name='Bedroom', class='RoomZoneQA', enabled=false, args={}},\n-- 'Kitchen table', Zone\n {id='fe101c36-3dcc-4831-90f1-5052fc54e08b', name='Kitchen table', class='RoomZoneQA', enabled=false, args={}},\n}\n","isOpen":false,"name":"Map"},{"isMain":false,"type":"lua","content":"QuickApp._betterQAversions=\"0.5\"\nfibaro.debugFlags = fibaro.debugFlags or {}\nfibaro.translations = fibaro.translations or {}\nQuickApp.language = nil\n\nlocal fmt = string.format\nfunction QuickApp:debugf(f,...) self:debug(fmt(f,...)) end\nfunction QuickApp:tracef(f,...) self:trace(fmt(f,...)) end\nfunction QuickApp:warningf(f,...) self:warning(fmt(f,...)) end\nfunction QuickApp:errorf(f,...) self:error(fmt(f,...)) end\n\nfunction DEBUG(flag,...)\n  if fibaro.debugFlags and fibaro.debugFlags[flag] then\n    fibaro.debug(__TAG,...)\n  end\nend\n\nlocal function getVariable(self,name)\n  __assert_type(name, \"string\")\n  for key,value in pairs(self.properties.quickAppVariables) do\n    if value.name == name then return value.value end\n  end\nend\n\nlocal function setVariable(self, name, value) \n  for k,variable in pairs(self.properties.quickAppVariables) do\n    if variable.name == name then\n      if value == nil then\n        table.remove(self.properties.quickAppVariables,k)\n      else variable.value = value end\n      self:updateProperty('quickAppVariables', self.properties.quickAppVariables)\n      return\n    end\n  end\n  if value == nil then return end\n  table.insert(self.properties.quickAppVariables, {name=name, value=value})\n  self:updateProperty('quickAppVariables', self.properties.quickAppVariables)\nend\n\nlocal _init = QuickApp.__init\n\nfunction QuickApp:__init(...)\n  local _onInit = self.onInit\n  self.translations = fibaro.translations\n  function self:onInit()\n    quickApp = self\n    self.qvar = setmetatable({},{\n      __index = function(t,k) return getVariable(self,k) end,\n      __newindex = function(t,k,v) return setVariable(self,k,v) end,   \n    })\n    self.storage = setmetatable({},{\n      __index = function(t,key) return self:internalStorageGet(key) end,\n      __newindex = function(t,key,val)\n        if val == nil then self:internalStorageRemove(key)\n        else self:internalStorageSet(key,val) end\n      end\n    })\n    if self.language == nil then\n      self.language = api.get(\"\/settings\/info\").defaultLanguage\n    end\n    self.lng = setmetatable({},{\n      __index = function(t,k)\n        local lang = self.language or \"en\"\n        local dict = self.translations[lang]\n        if not dict then self:warningf(\"Language not found: \",lang) return k end\n        if not dict[k] then self:warningf(\"Translation[%s].%s not found\",lang,k) return k end\n        return dict[k]\n      end,\n      __newindex = function(t,k,v)\n        local lang = self.language or \"en\"\n        self.translations[lang] = self.translations[lang] or {}\n        self.translations[lang][k] = v\n      end,\n    })\n    local dev = __fibaro_get_device(self.id)\n    if not dev.enabled then\n      if self.__disabled then pcall(self.__disabled,self) end\n      self:debug(\"QA \",self.name,\" disabled\")\n      function self.actionHandler() end -- Disable external calls\n      function self.UIHandler() end -- Disable UI events\n      return\n    end\n    if _onInit then _onInit(self) end\n  end\n  _init(self,...)\nend\n\nlocal _chilInit = QuickAppChild.__init\n\nfunction QuickAppChild:__init(...)\n  local _onInit = self.onInit\n  function self:onInit()\n    self.qvar = setmetatable({},{\n      __index = function(t,k) return getVariable(self,k) end,\n      __newindex = function(t,k,v) return setVariable(self,k,v) end,   \n    })\n    self.storage = setmetatable({},{\n      __index = function(key) return self:internalStorageGet(key) end,\n      __newindex = function(key,val)\n        if val == nil then self:internalStorageRemove(key)\n        else self:internalStorageSet(key,val) end\n      end\n    })\n    self.lng = quickApp.lng -- Children gets same language table as parent.\n    if _onInit then _onInit(self) end\n  end\n  _chilInit(self,...)\nend","isOpen":false,"name":"BetterQA"},{"isMain":true,"type":"lua","content":"---@diagnostic disable: undefined-global\n_DEVELOP = \"..\/..\/hc3emu\"\nif require and not QuickApp then require(\"hc3emu\") end\n\n--%%name=YahueV2\n--%%type=com.fibaro.deviceController\n--%%uid=UPD896846032517896\n--%%save=Yahue.fqa\n--%%var=Hue_IP:config.Hue_IP\n--%%var=Hue_User:config.Hue_user\n--%% merge=QAs\/HueV2Engine.lua,QAs\/HueV2App.lua,QAs\/HueV2File.lua\n--%%file=HueV2Engine.lua,Engine;\n--%%file=HueV2App.lua,App;\n--%%file=HueV2Map.lua,Map;\n--%%file=..\/..\/fibemu\/lib\/BetterQA.lua,BetterQA;\n--%% file=HueV2File.lua,HueV2;\n--%%u={label='info', text=''}\n--%%u={button='restart', text='Restart', onReleased='restart'}\n--%%u={button='dump', text='Dump resources', onReleased='dumpResources'}\n\nfibaro.debugFlags = fibaro.debugFlags or {}\nlocal HUE,update\n\nlocal function init()\n  local self = quickApp\n  self:debug(HUE.appName,HUE.appVersion)\n  self:updateView(\"info\",\"text\",HUE.appName..\" v\"..HUE.appVersion)\n\n  fibaro.debugFlags.info=true\n  --fibaro.debugFlags.class=true\n  fibaro.debugFlags.event=true\n  fibaro.debugFlags.call=true\n  local ip = (self.qvar.Hue_IP or \"\"):match(\"(%d+.%d+.%d+.%d+)\")\n  local key = self.qvar.Hue_User --:match(\"(.+)\")\n  assert(ip,\"Missing Hue_IP - hub IP address\")\n  assert(key,\"Missing Hue_User - Hue hub key\")\n\n  HUE:init(ip,key,function()\n    --HUEv2Engine:dumpDevices()\n    --HUE:dumpDeviceTable()\n    --HUE:listAllDevicesGrouped()\n    HUE:app()\n    end)\nend\n\nfunction QuickApp:onInit()\n  quickApp = self\n  HUE = HUEv2Engine\n  function self.initChildDevices() end\n  local updated = self:getVariable(\"update\")\n  if self.qvar.update==\"yes\" then\n    self:debug(\"Updating HueV2App\")\n    self.qvar.update=\"_\"\n    update()\n  elseif HUE then init() \n  else self:error(\"Missing HUE library, set QV update=yes\") end\nend\n\nfunction QuickApp:restart() plugin.restart() end\nfunction QuickApp:dumpResources() \n  if HUE then HUE:listAllDevicesGrouped() end\nend\n\nfunction update()\n  local baseURL = \"https:\/\/raw.githubusercontent.com\/jangabrielsson\/fibemu\/master\/\"\n  local file1 = baseURL..\"QAs\/HueV2File.lua\"\n  local function getFile(url,cont)\n    quickApp:debug(\"Fetching \"..url)\n    net.HTTPClient():request(url,{\n      options = { method = 'GET', checkCertificate=false, timeout=20000},\n      success = function(resp) cont(resp.data) end,\n      error = function(err) fibaro.error(__TAG,\"Fetching \"..err) end\n    })\n  end\n  getFile(file1,function(data1)\n    quickApp.qvar.update = os.date(\"%Y-%m-%d %H:%M:%S\")\n    local stat,err = api.put(\"\/quickApp\/\"..quickApp.id..\"\/files\",{\n      {name=\"HueV2\", isMain=false, isOpen=false, content=data1},\n    })\n    setTimeout(init,0)\n  end)\nend","isOpen":false,"name":"main"}],"name":"YahueV2"}